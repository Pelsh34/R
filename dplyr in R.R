# dplyr in R.

# Загрузим необходимые библиотеки:
library(dplyr)
library(ggplot2)


# Создадим стандартный и dplyr датафреймы:
my_data <- data_frame(x = rnorm(10000),
                      y = rnorm(10000),
                      f = factor(rep(1:2, 5000)))

my.data <- data.frame(x = rnorm(10000),
                      y = rnorm(10000),
                      f = factor(rep(1:2, 5000)))

# Следует отметить, что в консоли более удобно отсматривать
# информацию о датафрейме с помощью dplyr датафрейма!

# Любые датасеты можно просматривать в формате 
# dplyr формате!
diamonds <- as_data_frame(diamonds)
diamonds



# dplyr датафрейм не изменяет названия колонок, для названий с пробелами
# как это делает стандартный датафрейм:
my_data_2 <- data_frame('My var' = rnorm(10))
my.data.2 <- data.frame('My var' = rnorm(10))

# Можно использовать соседние переменные в датафрейме до 
# до выполнения команды data_frame():

my_data_2 <- data_frame(x = rnorm(10), y = abs(x))

# В то же время, стандартный датафрейм выдаст ошибку:
my.data.2 <- data.frame(x = rnorm(10, y = abs(x)))

# Функция select позволяет собирать нужные столбцы ######
# фунция slice - нужные строки.

# select удобен тем, что он получает на вход , сначала датафрейм
# а после запятой можно перечислять столбцы:

select(diamonds, cut, price)

# В стандартном синтаксисе эта же запись выглядит так:
diamonds[, c('cut', 'price', 'color')]

# Можем выбрать те колонки, которые находятся между выбранными:
select(diamonds, cut:price)

# Также можно выбрать весь датафрейм, но кроме некоторых:
select(diamonds, -cut:-price)

# Через стандартный датафрейм вышеуказанным способом убрать
# лишние столбцы не получается.

# Селектить можно и по индексам :
select(diamonds, 2)

# Также можно удобно искать переменные по разным аргументам,
# например ends_with, start_with, contain:

select(diamonds, contains('t'))

select(diamonds, ends_with('t'))

select(diamonds, starts_with('t'))
#############################################################

# Slice - эта функция позволяет получать сабсет , фильтрую по строкам:#########
slice(diamonds, c(1, 4, 5))

# В стандартном синтаксисе можем повторить:
diamonds[c(1, 4, 5), ]

#############################################################
# функция filter: ##############
filter(diamonds, carat > 0.3, color == 'J')

# В стандартном синтаксисе конструкция будет более громоздка
diamonds[diamonds$carat > 0.3 & diamonds$color == 'J', ]

# Также мы можем использовать функцию сабсет:
subset(diamonds, carat > 0.3 & color == 'J')
#############################################################
# Функция arrange сортирует датафрейм: ########
arrange(diamonds, -price, depth)

# В стандартном синтиаксисе конструкция будет крупнее:
diamonds[order(diamonds$price), ]

#############################################################

# Функция rename() - переименновывает колонки в датафрейме: #######

# Переименнуем переменную в датафрейме:
rename(diamonds, new_cut = cut, new_carat = carat)

# Тогда в стандартном синтиксисе:
names(mtcars)[c(1, which(names(mtcars) == 'hp'))] <- c('new_mpg', 'new_hp')

#############################################################

# Функция mutate() ################
# С помощью этой функции мы создаем новые переменные в нашем датафрейме:
m <- mutate(diamonds, sqrt_price = sqrt(price),
            log_carat = log(carat))




#############################################################

# Функция mutate_each(): #######
# Эта функция позволяет выполнять приобразование КАЖДОЙ колонки наших данных:


# Создадим датафрейм:
d <- tibble(matrix(rnorm(30), ncol = 5))

mutate_each(d, funs(abs))


# Если мы хотим заменить все отрицательные числа на 0, то выполним:
as_data_frame(sapply(d, function(x) ifelse(x < 0, 0, x)))

# Также можем прописать функцию, которая будет выполняться для каждого столбца:
mutate_each(d, funs(ifelse(. < 0, 0, .)))


# Например можем умножить все значения на 2:
mutate_each(d, funs(.*2))

#############################################################






























